<?cocoon-format type="text/html"><html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<title>Functional RuleML</title>
<style type="text/css">
       h1 { font-size: 32pt; font-weight: bold }
       h2 { font-size: 16pt; font-weight: bold }
       ul { line-height: 120% }
       ol { line-height: 120% }
       p { line-height: 100% }
     </style>
</head>
<body bgcolor="#FFFFFF">
		<center>
			<br>
			
			<br>
			<h1>Functional RuleML<br>
			</h1>
			<h2>Harold Boley, Doan Dai Duong, Le Thi Thu Thuy, Jie Li</h2>
			<br>
			<h2>Version History, 2006-07-08: Version 0.9
			</h2>
		</center>
		<br>
		<p>This page describes Functional RuleML (Fun RuleML),
		   which has been incorporated into RuleML since version 0.9. This develops RuleML into a Relational-Functional or Functional-Logic Markup Language (cf. <a href="http://www.relfun.org/rfml/">RFML</a>) that can be regarded as being composed of Relational RuleML plus Transformation Rules
                   (Oriented-Equality Definitions of Functions).
 </p>
	<h2>Contents</h2>
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Interpretedness And Valuedness">Interpretedness And Valuedness</a></li>
<li><a href="#Nestings And Equations">Nestings And Equations</a></li>
<li><a href="#Higher-Order Functions">Higher-Order Functions</a></li>
<li><a href="#RFML-to-RuleML Translation">RFML-to-RuleML Translation</a></li>
<li><a href="#Detailed Examples">Detailed Examples</a></li>
<li><a href="#Functional RuleML DTD">Functional RuleML DTD</a></li>
</ul>
<h2><a name="Overview">Overview</a></h2>
		
		<p>Functional programming (FP) is playing an increasing Web role, with MathML, XSLT and XQuery being prominent examples.
		We present here the design of <a href="ruleml-fun.pdf">Functional RuleML</a>
		(published as  <a href="http://www.cs.unb.ca/~boley/papers/ruleml-family.pdf">The RuleML Family of Web Rule Languages</a> in <a href="http://www.dbis.informatik.uni-goettingen.de/PPSWR06/ppswr06-program.html">PPSWR 2006</a>).
Functional RuleML is developed via orthogonal notions and freely combinable with the previous Relational RuleML, including OO RuleML. This will also allow for FP/LP-integrated programming (FLP), including OO FLP.
<br>
			<br>
Since its beginning in 2000, with RFML as one of its inputs, RuleML has permitted the markup of oriented (or directed) equations for defining the value(s) of a function applied to arguments, optionally conditional on a body as in Horn rules. Later, this was extended to logics with symmetric (or undirected) equality for the various sublanguages of RuleML, but the Equal element has still often exploited the left-to-right orientation of its (abridged) textual syntax. It has been a RuleML issue that the constructor <b>Ctor </b>of a complex term <b>Cterm</b> is disjoined, as an XML element, from the user-defined function <b>Fun</b> of a call expression Nano, although these can be unified by proceeding to a logic with equality. For example, while currently call patterns can contain Cterms but not Nanos, obeying the 'constructor discipline' , the latter should also be permitted to legalize 'optimization' rules like  <b>reverse(reverse(?L)) = ?L.</b>
			<br>
			<br>

Functional RuleML thus conceives both Cterms and Nanos as expression <b>(Expr)</b> elements and distinguishes <b>'uninterpreted' </b>(constructor) vs. <b>'interpreted'</b> (user-defined) functions just via an XML attribute; another attribute likewise distinguishes the (single- vs. set-)valuedness of functions. We then proceed to the nesting of all of these. Next, for defining (interpreted) functions, unconditional (oriented) equations are introduced. These are then extended to conditional equations, i.e. Horn logic implications with an equation as the head and possible equations in the body. Higher-order functions are finally added, both named ones such as <b>Compose</b> and <b>Lambda</b>-defined ones.
</p>
	<h2><a name="Interpretedness And Valuedness">Interpretedness And Valuedness</a></h2>
		
		<p>The different notions of <b>function</b> in LP and FP have been a continuing design issue:</p>
		<ul>
			<li>
				<i>Uninterpreted functions </i> denote unspecified values when applied to arguments, not using function definitions.
			</li>
			<li>
				<i>Interpreted functions </i>compute specified returned values when applied to arguments, using function definitions.
			</li>
		</ul>
		<p>For example, a function <b>first-born(John, Mary) </b>can be uninterpreted,  so that <b>first-born(John, Mary)</b> just denotes the first-born child; or, interpreted, e.g. using definition
<b>first-born(John, Mary) = Jory</b>, so the application <b>first-born(John, Mary)</b> returns <b>Jory</b>. These interpreted  and uninterpreted functions will be markup in RuleML as follows</p>
		<table border="0" cellspacing="" cellpadding="">
			<tr>
				<td>
					<b><pre>
    &lt;Expr&gt;
	&lt;Fun in=&quot;yes&quot;&gt;first-born&lt;/Fun&gt;
	&lt;Ind&gt;John&lt;/Ind&gt;
	&lt;Ind&gt;Mary&lt;/Ind&gt;
    &lt;/Expr&gt;</pre></b>
				</td>
				<td> and </td>
				<td>
					<b><pre>
	&lt;Expr&gt;
	  &lt;Fun in=&quot;no&quot;&gt;first-born&lt;/Fun&gt;
	  &lt;Ind&gt;John&lt;/Ind&gt;
	  &lt;Ind&gt;Mary&lt;/Ind&gt;
	&lt;/Expr&gt;</pre></b>
				</td>
			</tr>
		</table>
		<p>In both XML and UML processing, functions (like relations in LP) are often set-valued (non-deterministic). This is accommodated by introducing a <b>val</b>ued attribute with values including &quot;1&quot; (deterministic: exactly one) and &quot;0..&quot; (set-valued: zero or more). For example, the set-valued function <b>children(John, Mary) </b>can be interpreted and set-valued, using definition <b> children(John, Mary) =
{Jory, Mahn} </b>, so that the application <b>children(John, Mary) </b>returns <b>{Jory,Mahn} </b>. The example is then marked up thus</p>
		<b><pre>
&lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot; val=&quot;0..&quot;&gt;children&lt;/Fun&gt;
   &lt;Ind&gt;John&lt;/Ind&gt;
   &lt;Ind&gt;Mary&lt;/Ind&gt;
&lt;/Expr&gt;
</pre></b>
	<h2><a name="Nestings And Equations">Nestings And Equations</a></h2>
		
		<p>Nestings are permitted for all combinations of interpreted and uninterpreted functions.
		Equations are used both as test queries and for function definitions.
		Let us consider an example defining a function <i>home</i> for a given structured argument:</p>
		<i> home(father-of(John)) = Mexico City </i>
		<p>This will be marked up as follows</p>
		<b><pre>
&lt;Equal oriented=&quot;yes&quot;&gt;
  &lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot;&gt;home&lt;/Fun&gt;
     &lt;Expr&gt;
       &lt;Fun in=&quot;no&quot;&gt;father-of&lt;/Fun&gt;
       &lt;Ind&gt;John&lt;/Ind&gt;
     &lt;/Expr&gt;
  &lt;/Expr&gt;
  &lt;Ind&gt;Mexico City&lt;/Ind&gt;
&lt;/Equal&gt;
</pre></b>
		<p>Here, the <b>Equal</b> element represents an unconditional, oriented equation. In general, <b>Equal</b> permits both symmetric (or undirected) and oriented (or directed) equations via an <b>oriented</b> attribute with respective &quot;no&quot;
and &quot;yes&quot; values. Since it is more general, oriented=&quot;no&quot; is proposed as the default.
		</p>
		<p>Let us consider a more involved example </p>
		<i> home(father-of(John)) = largest-city(Earth)</i>
		<p>In this example assume that the right-hand side of the equation should call an interpreted function.
		This leads to the following markup: </p>
		<b><pre>
&lt;Equal oriented=&quot;yes&quot;&gt;
  &lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot;&gt;home&lt;/Fun&gt;
     &lt;Expr&gt;
       &lt;Fun in=&quot;no&quot;&gt;father-of&lt;/Fun&gt;
       &lt;Ind&gt;John&lt;/Ind&gt;
     &lt;/Expr&gt;
  &lt;/Expr&gt;
  &lt;Expr&gt;
    &lt;Fun in=&quot;yes&quot;&gt;largest-city&lt;/Fun&gt;
    &lt;Ind&gt;Earth&lt;/Ind&gt;
  &lt;/Expr&gt;
&lt;/Equal&gt;
</pre></b>
	<h2><a name="Higher-Order Functions">Higher-Order Functions</a></h2>
		
		<p>Higher-order functions are characteristic for FP and thus should be supported by Functional RuleML. A higher-order function permits functions to be passed to it as (actual)
parameters and to be returned from it as values. For example, the composition of an age function and the first-born function (introduced above), both interpreted, is performed by Compose(age,first-born).
This example can be marked up thus:</p>
		<b><pre>
&lt;Expr in=&quot;yes&quot;&gt;
  &lt;Fun in=&quot;no&quot;&gt;Compose&lt;/Fun&gt;
  &lt;Fun in=&quot;yes&quot;&gt;age&lt;/Fun&gt;
  &lt;Fun in=&quot;yes&quot;&gt;first-born&lt;/Fun&gt;
&lt;/Expr&gt;
</pre></b>
<p>Here, as in RFML, <b>Compose</b> itself is marked up as an uninterpreted function,
while the enclosing <b>Expr</b> is employed as an interpreted function
having the entire <b>Compose</b> application as its structured name.
This composition can be applied to two (parent) individuals thus:</p>
		<b><pre>
&lt;Expr&gt;
  &lt;Expr in=&quot;yes&quot;&gt;
    &lt;Fun in=&quot;no&quot;&gt;Compose&lt;/Fun&gt;
    &lt;Fun in=&quot;yes&quot;&gt;age&lt;/Fun&gt;
    &lt;Fun in=&quot;yes&quot;&gt;first-born&lt;/Fun&gt;
  &lt;/Expr&gt;
  &lt;Ind&gt;John&lt;/Ind&gt;
  &lt;Ind&gt;Mary&lt;/Ind&gt;
&lt;/Expr&gt;
</pre></b>
<p>Further information, e.g. on attribute defaults and <b>Lambda</b>-defined functions,
is given in the <a href="ruleml-fun.pdf">Functional RuleML</a> paper.</p>
	<h2><a name="RFML-to-RuleML Translation">RFML-to-RuleML Translation</a></h2>
		
		<p>The functional part of Relfun's RFML syntax can be translated into Fun RuleML using the <a href="http://www.ruleml.org/fun/rfml2ruleml.xslt">RFML2RuleML.xslt</a> stylesheet, which was
                 adapted from an <a href="http://www.relfun.org/ruleml/rfml2ruleml.xsl">earlier stylesheet</a> for mapping a Hornlog RFML program into an older version
                 of RuleML. The new stylesheet is designed to map the functional part of RFML into RuleML 0.9.</p>
	<h2><a name="Detailed Examples">Detailed Examples</a></h2>
		
		<p>	The following are some more detailed Functional RuleML examples, e.g. for testing the translator:</p>
		<ul>
			<li>FatherOfJohn in Functional RuleML: <a href="http://www.ruleml.org/fun/FatherOfJohn.xml">FatherOfJohn.xml</a>
			</li>
		</ul>
		<p>and</p>
		<ul>
			<li>RFMLFact.xml in RFML: <a href="http://www.ruleml.org/fun/RFMLFact.xml">RFMLFact.xml</a>
			</li>
		</ul>
		<ul>
			<li>RuleMLResult.xml in RuleML: <a href="http://www.ruleml.org/fun/RuleMLResult.xml">RuleMLResult.xml</a>
			</li>
		</ul>
	<h2><a name="Functional RuleML DTD">Functional RuleML DTD</a></h2>
		
		<b><pre>
&lt;!ENTITY % term &quot;(Data | Ind | Var | Expr)&quot;&gt;
&lt;!ENTITY % ateq &quot;(Atom | Equal)&quot;&gt;
&lt;!ENTITY % conclusion &quot;(%ateq;)&quot;&gt;
&lt;!ENTITY % condition &quot;(And | %ateq;)&quot;&gt;
&lt;!ELEMENT Assert (Implies | %ateq;)*&gt;
&lt;!ELEMENT Implies (%condition;, %conclusion;)&gt;
&lt;!ELEMENT And (%ateq;)*&gt;
&lt;!ELEMENT Equal (%term;, %term;)&gt;
&lt;!ELEMENT Atom ((Rel | Expr | Lambda | Var), (%term; | Rel | Fun | Lambda)*)&gt;
&lt;!ELEMENT Expr ((Fun | Expr | Lambda | Var), (%term; | Rel | Fun | Lambda)*)&gt;
&lt;!ELEMENT Lambda ((%term;)+, %term;)&gt;
&lt;!ELEMENT Fun (#PCDATA)&gt;
&lt;!ELEMENT Rel (#PCDATA)&gt;
&lt;!ELEMENT Data (#PCDATA)&gt;
&lt;!ELEMENT Ind (#PCDATA)&gt;
&lt;!ELEMENT Var (#PCDATA)&gt;
&lt;!ATTLIST Equal oriented (yes | no) &quot;no&quot;&gt;
&lt;!ATTLIST Expr	in (yes | no | semi) &quot;semi&quot;&gt;
&lt;!ATTLIST Rel	in (yes | no | semi) &quot;semi&quot;&gt;
&lt;!ATTLIST Fun	in (yes | no | semi) &quot;semi&quot;
		val (1 | 0..) &quot;0..&quot;&gt;
&lt;!ATTLIST Var	ord (1 | h) &quot;h&quot;
		in (yes | no | semi) &quot;semi&quot;&gt;
		</pre></b>
	<br>
		<p>
		Site Contact:
		<a href="http://www.cs.unb.ca/~boley/">Harold Boley</a>.
		Page Version: 2006-07-08
		
		<br>
			<br>
			<br>
			<a name="Practice-Preach"></a>
			<small>&quot;Practice what you preach&quot;: XML source of this homepage at <a href="index.xml">index.xml</a>;
	      <br>
	      transformed to HTML via the adaptation of <a href="http://www.dfki.uni-kl.de/~sintek/">Michael Sintek</a>'s SliML <a href="http://www.w3.org/TR/xslt">XSLT</a> stylesheet at <a href="http://www.dfki.uni-kl.de/~boley/xslt/homepage.xsl">homepage.xsl</a> (View | Page Source)
	   </small>
		</p>
	</body>
</html>
