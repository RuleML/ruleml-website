<?cocoon-format type="text/html"><html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<title>Functional RuleML</title>
<style type="text/css">
       h1 { font-size: 32pt; font-weight: bold }
       h2 { font-size: 16pt; font-weight: bold }
       ul { line-height: 120% }
       ol { line-height: 120% }
       p { line-height: 100% }
       dt { font-weight: bold }
       abbr, acronym { cursor:help }
     </style>
</head>
<body bgcolor="#FFFFFF">
		<center>
			<br>
			
			<br>
			<h1>Functional RuleML<br>
			</h1>
			<h2>Harold Boley, Doan Dai Duong, Le Thi Thu Thuy, Jie Li</h2>
			<br>
			<h2>Version History, 2005-10-31: Version 0.89
			</h2>
		</center>
		<br>
		<p>This pape describes <a href="http://www.upgrade-cepis.org/issues/2005/6/up6-6Boley.pdf">Functional RuleML </a>(Fun RuleML), which has been incorporated into RuleML since version 0.9. It can be regarded as the Present RuleML + Transformation Rules
                 (Oriented Equality Definitions of Functions).
 </p>
	<h2>Contents</h2>
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Interpretedness And Valuedness">Interpretedness And Valuedness</a></li>
<li><a href="#Nesting">Nesting</a></li>
<li><a href="#Higher-Order Functions">Higher-Order Functions</a></li>
<li><a href="#XSLT Stylesheet">XSLT Stylesheet</a></li>
<li><a href="#Samples">Samples</a></li>
<li><a href="#Functional RuleML DTD">Functional RuleML DTD</a></li>
</ul>
<h2><a name="Overview">Overview</a></h2>
		
		<p>Functional programming (FP) is also playing an increasing Web role, with XSLT and XQuery being prominent examples. We present here the design of Functional RuleML,
developed via orthogonal notions and freely combinable with the previous Relational RuleML, including OO RuleML. This will also allow for FP/LP-integrated programming (FLP), including OO FLP.
<br>
			<br>
Since its beginning in 2000, with RFML as one of its inputs, RuleML has permitted the markup of oriented (or directed) equations for defining the value(s) of a function applied to arguments, optionally conditional on a body as in Horn rules. Later, this was extended to logics with symmetric (or undirected) equality for the various sublanguages of RuleML, but the Equal element has still often exploited the left-to-right orientation of its (abridged) textual syntax. It has been a RuleML issue that the constructor <b>Ctor </b>of a complex term <b>Cterm</b> is disjoined, as an XML element, from the user-defined function <b>Fun</b> of a call expression Nano, although these can be unified by proceeding to a logic with equality. For example, while currently call patterns can contain Cterms but not Nanos, obeying the 'constructor discipline' , the latter should also be permitted to legalize `optimization' rules like  <b>reverse(reverse(?L)) = ?L.</b>
			<br>
			<br>

This paper thus conceives both Cterms and Nanos as expression <b>(Expr)</b> elements and distinguishes <b>`uninterpreted' </b>(constructor) vs. <b>`interpreted'</b> (user-defined) functions just via an XML attribute; another attribute likewise distinguishes the (single- vs. set-)valuedness of functions. We then proceed to the nesting of all of these. Next, for defining (interpreted) functions, unconditional (oriented) equations are introduced. These are then extended to conditional equations, i.e. Horn logic implications with an equation as the head and possible equations in the body. Higher-order functions are finally added, both named ones such as <b>Compose </b>and <b>Lambda-defined </b>ones.
</p>
	<h2><a name="Interpretedness And Valuedness">Interpretedness And Valuedness</a></h2>
		
		<p>The different notions of _function_ in LP and FP have been a continuing design issue:</p>
		<ul>
			<li>
				<i>Uninterpreted functions </i> denote unspecified values when applied to arguments, not using function definitions.
			</li>
			<li>
				<i>Interpreted functions </i>compute specified returned values when applied to arguments, using function definitions.
			</li>
		</ul>
		<p>For example, a function <b>first-born(John, Mary) </b>can be uninterpreted,  so that <b>first-born(John, Mary) </b> just denotes the first-born child; or, interpreted, e.g. using definition
<b>first-born(John, Mary) = Jory </b>, so the application returns <b>Jory </b>.These interpreted  and uninterpreted functions will be markup in RuleML as follows</p>
		<table border="0" width="75%">
			<tr align="center">
				<td>
					<code>
    <Expr>
	<Fun in="yes">first-born</Fun>
	<Ind>John</Ind>
	<Ind>Mary</Ind>
    </Expr>		    
		    </code>
				</td>
				<td> and </td>
				<td>
					<code>
	<Expr>
	  <Fun in="no">first-born</Fun>
	  <Ind>John</Ind>
	  <Ind>Mary</Ind>
	</Expr>		    
		    </code>
				</td>
			</tr>
		</table>
		<p>In both XML and UML processing, functions (like relations in LP) are often setvalued (non-deterministic). This is accommodated by introducing a valued attribute with values including &quot;1&quot; (deterministic: exactly one) and &quot;0..&quot; (set-valued: zero or more). For example, the set-valued function <b>children(John, Mary) </b>can be interpreted and set-valued, using definition <b> children(John, Mary) =
{Jory, Mahn} </b>, so that the application <b>children(John, Mary) </b>returns <b>{Jory,Mahn} </b>. The example is then marked up thus</p>
		<code>
&lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot; val=&quot;0..&quot;&gt;children&lt;/Fun&gt;
   &lt;Ind&gt;John&lt;/Ind&gt;
   &lt;Ind&gt;Mary&lt;/Ind&gt;
&lt;/Expr&gt;
</code>
	<h2><a name="Nesting">Nesting</a></h2>
		
		<p>One of the advantages of interpreted functions as compared to relations is that the returned values of their applications permit nestings, avoiding flat relational conjunctions
with shared logic variables. Let's consider an example:</p>
		<i> home(father-of(John)) = Mexico City </i>
		<p>This will be markup as follows</p>
		<code>

&lt;Equal oriented=&quot;yes&quot;&gt;
  &lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot;&gt;home&lt;/Fun&gt;
     &lt;Expr&gt;
	   &lt;Fun in=&quot;no&quot;&gt;father-of&lt;/Fun&gt;
	   &lt;Ind&gt;John&lt;/Ind&gt;
     &lt;/Expr&gt;
  &lt;/Expr&gt;
  &lt;Ind&gt;Mexico City&lt;/Ind&gt;
&lt;/Equal&gt;
</code>
		<p>Here <b>Equal</b>  element represents un-conditional equations, permitting both symmetric (or undirected) and oriented (or directed) equations via an oriented attribute with respective &quot;no&quot;
and &quot;yes&quot; values. Since it is more general, oriented=&quot;no&quot; is proposed as the default.
		</p>
		<p>Let cosider a more complicated example </p>
		<i> home(father-of(John)) = largest-city(Earth)</i>
		<p>With this example, the &quot;righ hand side&quot; of the Equal equation should be an intepreted function. This leads to the following markup: </p>
		<code>
		
&lt;Equal oriented=&quot;yes&quot;&gt;
  &lt;Expr&gt;
   &lt;Fun in=&quot;yes&quot;&gt;home&lt;/Fun&gt;
     &lt;Expr&gt;
        &lt;Fun in=&quot;no&quot;&gt;father-of&lt;/Fun&gt;
	 &lt;Ind&gt;John&lt;/Ind&gt;
     &lt;/Expr&gt;
  &lt;/Expr&gt;
  &lt;Expr&gt;
     &lt;Fun in=&quot;yes&quot;&gt;largest-city&lt;/Fun&gt;
     &lt;Ind&gt;Earth&lt;/Ind&gt;
  &lt;/Expr&gt;
&lt;/Equal&gt;
</code>
	<h2><a name="Higher-Order Functions">Higher-Order Functions</a></h2>
		
		<p>Higher-order functions are characteristic for FP and thus should be supported by Functional RuleML. A higher-order function permits functions to be passed to it as (actual)
parameters and to be returned from it as values. For example, the composition of the first-born function (introduced in previous section) and a value 17 is performed by Compose(first-born,17). This sample can be markup thus:</p>
		<code>
 &lt;Expr&gt;
   &lt;Fun&gt;Compose&lt;/Fun&gt;
   &lt;Fun in=&quot;yes&quot;&gt;first-born&lt;/Fun&gt;
   &lt;Ind&gt;17&lt;/Ind&gt;
&lt;/Expr&gt;
</code>
	<h2><a name="XSLT Stylesheet">XSLT Stylesheet</a></h2>
		
		<p>The funtional part of Relfun syntax is converted into Fun RuleML using the <a href="http://www.ruleml.org/fun/rfml2ruleml.xslt">RFML2RuleML.xslt</a> stylesheet which has been
                 adapted from an <a href="http://www.relfun.org/ruleml/rfml2ruleml.xsl">earlier stylesheet</a> for mapping a Hornlog RFML program into an older version
                 of a RuleML rulebase. The new stylesheet is designed to map the Functional part of RFML into RuleML 0.9.</p>
	<h2><a name="Samples">Samples</a></h2>
		
		<p>	The following are some Fuontional RuleML examples</p>
		<ul>
			<li>FatherOfJohn in Functional RuleML: <a href="http://www.ruleml.org/fun/FatherOfJohn.xml">FatherOfJohn.xml</a>
			</li>
		</ul>
		<p>and</p>
		<ul>
			<li>RFMLFact.xml in RFML: <a href="http://www.ruleml.org/fun/RFMLFact.xml">RFMLFact.xml</a>
			</li>
		</ul>
		<ul>
			<li>RuleMLResult.xml in RuleML: <a href="http://www.ruleml.org/fun/RuleMLResult.xml">RuleMLResult.xml</a>
			</li>
		</ul>
	<h2><a name="Functional RuleML DTD">Functional RuleML DTD</a></h2>
		
		<code>

&lt;!ENTITY % term &quot;(Data | Ind | Var | Expr)&quot;&gt;
&lt;!ENTITY % ateq &quot;(Atom | Equal)&quot;&gt;
&lt;!ENTITY % conclusion &quot;(%ateq;)&quot;&gt;
&lt;!ENTITY % condition &quot;(And | %ateq;)&quot;&gt;
&lt;!ELEMENT Assert (Implies | %ateq;)*&gt;
&lt;!ELEMENT Implies (%condition;, %conclusion;)&gt;
&lt;!ELEMENT And (%ateq;)*&gt;
&lt;!ELEMENT Equal (%term;, %term;)&gt;
&lt;!ELEMENT Atom ((Rel | Expr | Lambda | Var), (%term; | Rel | Fun | Lambda)*)&gt;
&lt;!ELEMENT Expr ((Fun | Expr | Lambda | Var), (%term; | Rel | Fun | Lambda)*)&gt;
&lt;!ELEMENT Lambda ((%term;)+, %term;)&gt;
&lt;!ELEMENT Fun (#PCDATA)&gt;
&lt;!ELEMENT Rel (#PCDATA)&gt;
&lt;!ELEMENT Data (#PCDATA)&gt;
&lt;!ELEMENT Ind (#PCDATA)&gt;
&lt;!ELEMENT Var (#PCDATA)&gt;
&lt;!ATTLIST Equal oriented (yes | no) &quot;no&quot;&gt;
&lt;!ATTLIST Expr	in (yes | no | semi) &quot;semi&quot;&gt;
&lt;!ATTLIST Rel	in (yes | no | semi) &quot;semi&quot;&gt;
&lt;!ATTLIST Fun	in (yes | no | semi) &quot;semi&quot;
		val (1 | 0..) &quot;0..&quot;&gt;
&lt;!ATTLIST Var	ord (1 | h) &quot;h&quot;
		in (yes | no | semi) &quot;semi&quot;&gt;
		</code>
	<br>
		<p>
		Site Contact:
		<a href="http://www.cs.unb.ca/~boley/">Harold Boley</a>.
		Page Version: 2005-10-31
		
		<br>
			<br>
			<br>
			<a name="Practice-Preach"></a>
			<small>&quot;Practice what you preach&quot;: XML source of this homepage at <a href="index.xml">index.xml</a>;
	      <br>
	      transformed to HTML via the adaptation of <a href="http://www.dfki.uni-kl.de/~sintek/">Michael Sintek</a>'s SliML <a href="http://www.w3.org/TR/xslt">XSLT</a> stylesheet at <a href="http://www.dfki.uni-kl.de/~boley/xslt/homepage.xsl">homepage.xsl</a> (View | Page Source)
	   </small>
		</p>
	</body>
</html>
