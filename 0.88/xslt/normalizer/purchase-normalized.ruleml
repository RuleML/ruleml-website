<?xml version="1.0" encoding="UTF-8"?><Assert xmlns="http://www.ruleml.org/0.88/xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.ruleml.org/0.88/xsd&#xA;http://www.ruleml.org/0.88/xsd/equalog.xsd">	<!--The function symbol "owner" could be user-defined by a ruleor 'directed Equaluation' owner(car17) = john. Now, the first premise ofthe 'functional Datalog' rulebuy(Person,Object) <- pay(Person,owner(Object)) and take(Person,Object)is an "owner" function call nested into a "pay" relation call. Withadditional facts pay(fred,john) and take(fred,car17) also asserted,the "buy" relation call buy(fred,car17) would be computed thus:buy(fred,car17)pay(fred,owner(car17)) and take(fred,car17)pay(fred,john)         and truetrue                   and truetrueSo, owner(car17) _computes_ the actual owner individual, rather thanjust _denoting_ it, as a cterm with a constructor symbol "owner"would. For this corresponding cterm in the first premise, we wouldhave used square brackets like pay(Person,owner[car17]), but then oneasserted fact would have to be the non-Datalog pay(fred,owner[car17]).Now, the above 'functional Datalog' rule can be flattened, obtainingbuy(Person,Object) <- Own = owner(Object) and pay(Person,Own)                      and take(Person,Object)This flattened version, along with the directed Equaluation and facts, canbe marked up in the current RuleML as follows:-->	<content>		<And innerclose="existential">			<formula>				<Equal>					<side>						<Nano>							<opf>								<Fun>owner</Fun>							</opf>							<arg index="1">								<Ind>car17</Ind>							</arg>						</Nano>					</side>					<side>						<Ind>john</Ind>					</side>				</Equal>			</formula>			<formula>				<Implies>					<head>						<Atom>							<opr>								<Rel>buy</Rel>							</opr>							<arg index="1">								<Var>person</Var>							</arg>							<arg index="2">								<Var>object</Var>							</arg>						</Atom>					</head>					<body>						<And>							<formula>								<Equal>									<side>										<Var>own</Var>									</side>									<side>										<Nano>											<opf>												<Fun>owner</Fun>											</opf>											<arg index="1">												<Var>object</Var>											</arg>										</Nano>									</side>								</Equal>							</formula>							<formula>								<Atom>									<opr>										<Rel>pay</Rel>									</opr>									<arg index="1">										<Var>person</Var>									</arg>									<arg index="2">										<Var>own</Var>									</arg>								</Atom>							</formula>							<formula>								<Atom>									<opr>										<Rel>take</Rel>									</opr>									<arg index="1">										<Var>person</Var>									</arg>									<arg index="2">										<Var>object</Var>									</arg>								</Atom>							</formula>						</And>					</body>				</Implies>			</formula>			<formula>				<Atom>					<opr>						<Rel>pay</Rel>					</opr>					<arg index="1">						<Ind>fred</Ind>					</arg>					<arg index="2">						<Ind>john</Ind>					</arg>				</Atom>			</formula>			<formula>				<Atom>					<opr>						<Rel>take</Rel>					</opr>					<arg index="1">						<Ind>fred</Ind>					</arg>					<arg index="2">						<Ind>car17</Ind>					</arg>				</Atom>			</formula>		</And>	</content></Assert>